#!/usr/bin/python
'''
 * This software was created by United States Government employees
 * and may not be copyrighted.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
'''
import os
import sys
import logging
import argparse
from monitorLibs import configMgr
from monitorLibs import szk
class listRepo():
    def __init__(self):
        cfg = configMgr.configMgr()
        zk = szk.szk(None, cfg)
        self.cbs_dir = cfg.cb_dir
        self.lgr = logging
        if not os.path.isdir(self.cbs_dir):
            print('Error: no repo found at %s'% (self.cbs_dir))
            print('If running Ida client, try using lRepo instead')
            exit(1)
        self.cb_list = os.listdir(self.cbs_dir)
        self.cb_list.sort()

    def isPoll(self, poll):
        if poll.startswith(szk.POLL):
            return True
        else:
            return False

    def isPoV(self, pov):
        if pov.startswith(szk.POV):
            return True
        else:
            return False

    def listCBs(self):
        cbs = os.listdir(self.cbs_dir)
        for cb in self.cb_list:
            print('CB: %s' % cb)

    def findCB(self, a_cb):
        for cb in self.cb_list:
            if a_cb in cb:
                return cb
        return None

    def listCB(self, cb, just_povs):
            # get author's mitigated CB if any
            a_mg_path = os.path.join(self.cbs_dir, cb, szk.AUTHOR, cb+'_'+szk.MG)
            self.lgr.debug( 'cb is %s' % cb)
            print cb
            #self.lgr.debug( 'a_mg_path is %s' % a_mg_path)
            cb_mg = None
            if os.path.isdir(a_mg_path):
                cb_mg = cb+'_'+szk.MG
                print cb_mg

            # get povs generated by the CB author
            a_pov_dir = os.path.join(self.cbs_dir, cb, szk.AUTHOR, szk.POVs)
            if os.path.isdir(a_pov_dir):
                author_povs = os.listdir(a_pov_dir)
                for pov_d_name in author_povs:
                    pov_f_name = pov_d_name+'.xml'
                    self.lgr.debug('check author_povs: %s' % pov_f_name)
                    if self.isPoV(pov_f_name):
                       pov = pov_f_name[:len(pov_f_name)-4]
                       self.lgr.debug('put pov for %s' % pov)
                       print('%s  %s' % (pov, cb))
            else:
                print 'no author pov files for %s' % a_pov_dir
            if not just_povs:
                # get polls generated by the CB author
                a_poll_dir = os.path.join(self.cbs_dir, cb, szk.AUTHOR, szk.POLLs)
                if os.path.isdir(a_poll_dir):
                    author_polls = os.listdir(a_poll_dir)
                    for poll_d_name in author_polls:
                        poll_f_name = poll_d_name+'.xml'
                        if self.isPoll(poll_f_name):
                           poll = poll_f_name[:len(poll_f_name)-4]
                           print poll
                else:
                    print 'no author poll files for %s' % a_poll_dir
   
            # get mitigated CBs and povs generated by competitors 
            cmp_dir = os.path.join(self.cbs_dir, cb, szk.COMPETITOR)
            if os.path.isdir(cmp_dir):
                cmps = os.listdir(cmp_dir)
                for competitor in cmps:
                    c_pov_dir = os.path.join(cmp_dir, competitor, szk.POVs)
                    #print 'check c_pov_dir %s' % c_pov_dir
                    if os.path.isdir(c_pov_dir):
                        # do PoVs generated by this competitor
                        competitor_povs = os.listdir(c_pov_dir)
                        for pov_d_name in competitor_povs:
                            pov_f_name = pov_d_name+'.xml'
                            if self.isPoV(pov_f_name):
                               self.lgr.debug('do pov %s for CB %s' % (pov_f_name, cb))
                               pov = pov_f_name[:len(pov_f_name)-4]
                               print 'pov is '+pov
                    else:
                        print 'no competitor pov files at %s' % c_pov_dir
                    if not just_povs:
                        c_cb_dir = os.path.join(cmp_dir, competitor, szk.CBs)
                        #print 'check c_cb_dir %s' % c_cb_dir
                        if os.path.isdir(c_cb_dir):
                            # do CBs generated by this competitor
                            competitor_cbs = os.listdir(c_cb_dir)
                            if len(competitor_cbs) > 1:
                                print 'more than one mitigated cb for competitor at %s' % c_cb_dir
                                #exit(1)
                            else:
                                print competitor_cbs[0]
                            for cb_f_name in competitor_cbs:
                                should_be = cb+'_'+competitor
                                if not cb_f_name.startswith(should_be):
                                    print 'unexpected cb name in %s: %s' % (c_cb_dir, cb_f_name)
                                    exit(1)
                        else:
                            print 'no competitor mitigated CB files at %s' % c_pov_dir
                           
            else:
                print 'no competitor pov files for %s' % a_pov_dir

    def listAll(self, just_povs):
        cbs = os.listdir(self.cbs_dir)
        cbs.sort()
        for cb in cbs:
            self.listCB(cb, just_povs)
        print('   %d CBs' % len(cbs))

def usage():
    print('listRepo [-v | -h | CB]')
    print('\t List CBs in the file repo, e.g., those that can be used in the debugger')
    print('\t options:')
    print('\t\t CB  A CSID, if provided, all assocated replays are also displayed (in form convenient for cut/past to oneThrow)')
    print('\t\t -v  show all CBs and their replays')
    print('\t\t -h  this help')
if __name__ == "__main__":
    lr = listRepo()
    parser = argparse.ArgumentParser(description='List CBs and replays in the CGC Monitor file repo')
    parser.add_argument('cb_id', nargs='?', default = None, 
         help="optional name of CB whose replays should be listed")
    parser.add_argument('-v', '--verbose', action='store_true', default=False, 
         help='show all CBs and their replays')
    parser.add_argument('-p', '--povs', action='store_true', default=False, help='only display PoVs')
    args = parser.parse_args()
    if args.cb_id is not None:
        cb = lr.findCB(args.cb_id)
        if cb is not None:
            lr.listCB(cb, args.povs)
        else:
            print('no CB found like %s' % args.cb_id)
    elif args.verbose:
        lr.listAll(args.povs)
    else:
        lr.listCBs()
 
